#include "aes_encryption_system.h"
#include <iostream>
#include <cstring>

#define LOG(x) std::cout << x << std::endl

AESEncryptionSystem::AESEncryptionSystem() {
    currentState = Idle::instance();
	currentMode = AESMode::NONE;
    LOG("[Context] Created. Initial state = " << currentState->name());
}

AESEncryptionSystem::~AESEncryptionSystem() { LOG("[Context] Destroyed."); }

void AESEncryptionSystem::setMode(AESMode mode) {
	LOG("[Context] Mode set to " << (mode == AESMode::ENCRYPT ? "Encrypt" : "Decrypt"));
    currentMode = mode;
}

void AESEncryptionSystem::setState(AESState* newState) {
    LOG("[Context] Transition: " << currentState->name() << " -> " << newState->name());
    currentState = newState;
    currentState->onEntry(this);
}

void AESEncryptionSystem::load_key(const uint8_t* key) {
    currentState->load_key(this, key);
}

void AESEncryptionSystem::set_mode(AESMode mode) {
    currentState->set_mode(this, mode);
}

void AESEncryptionSystem::load_data(const uint8_t* data) {
    currentState->load_data(this, data);
}

void AESEncryptionSystem::start() {
    currentState->start(this);
}

void AESEncryptionSystem::read_result(uint8_t* out) {
    currentState->read_result(this, out);
}

void AESEncryptionSystem::invalid_command() {
    currentState->invalid_command(this);
}

void AESEncryptionSystem::reset() {
    currentState->reset(this);
}

// Helpers
void AESEncryptionSystem::setKey(const uint8_t* key) {
	std::memcpy(key_, key,16);
}

void AESEncryptionSystem::setData(const uint8_t* data) {
	std::memcpy(data_in_, data,16);
}

static uint8_t sbox[256] = {
	//256-byte AES S-Box values
0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
};

static uint8_t rcon[11] = {0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36 };

static void KeyExpansion(const uint8_t* key, uint8_t roundKeys[176]) {
	std::memcpy(roundKeys, key,16);
	uint8_t temp[4];
	int bytesGenerated =16;
	int rconIter =1;

	while (bytesGenerated <176) {
		for (int i =0; i <4; ++i) temp[i] = roundKeys[bytesGenerated -4 + i];
		if (bytesGenerated %16 ==0) {
			// rotate
			uint8_t t = temp[0]; temp[0] = temp[1]; temp[1] = temp[2]; temp[2] = temp[3]; temp[3] = t;
			// sub
			for (int i =0; i <4; ++i) temp[i] = sbox[temp[i]];
			temp[0] ^= rcon[rconIter++];
		}
		for (int i =0; i <4; ++i) {
			roundKeys[bytesGenerated] = roundKeys[bytesGenerated -16] ^ temp[i];
			++bytesGenerated;
		}
	}
}

static uint8_t xtime(uint8_t x) { return (uint8_t)((x <<1) ^ ((x &0x80) ?0x1b :0x00)); }
static uint8_t mul(uint8_t x, uint8_t m) {
	switch (m) {
		case 0x01: return x;
		case 0x02: return xtime(x);
		case 0x03: return (uint8_t)(xtime(x) ^ x);
		case 0x09: return (uint8_t)(xtime(xtime(xtime(x))) ^ x);
		case 0x0b: return (uint8_t)(xtime(xtime(xtime(x)) ) ^ xtime(x) ^ x);
		case 0x0d: return (uint8_t)(xtime(xtime(xtime(x)) ) ^ xtime(xtime(x)) ^ x);
		case 0x0e: return (uint8_t)(xtime(xtime(xtime(x)) ) ^ xtime(xtime(x)) ^ xtime(x));
		default: return 0;
	}
}

static void SubBytes(uint8_t* s) { for (int i =0; i <16; ++i) s[i] = sbox[s[i]]; }
static void ShiftRows(uint8_t* s) {
	uint8_t t[16];
	t[0] = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
	t[4] = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
	t[8] = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	std::memcpy(s, t,16);
}
static void MixColumns(uint8_t* s) {
	for (int c =0; c <4; ++c) {
		int i =4 * c;
		uint8_t a0 = s[i], a1 = s[i +1], a2 = s[i +2], a3 = s[i +3];
		s[i] = (uint8_t)(mul(a0,0x02) ^ mul(a1,0x03) ^ a2 ^ a3);
		s[i +1] = (uint8_t)(a0 ^ mul(a1,0x02) ^ mul(a2,0x03) ^ a3);
		s[i +2] = (uint8_t)(a0 ^ a1 ^ mul(a2,0x02) ^ mul(a3,0x03));
		s[i +3] = (uint8_t)(mul(a0,0x03) ^ a1 ^ a2 ^ mul(a3,0x02));
	}
}
static void AddRoundKey(uint8_t* s, const uint8_t* rk) { for (int i =0; i <16; ++i) s[i] ^= rk[i]; }

static void InvSubBytes(uint8_t* s) {
	static uint8_t invs[256];
	static bool inited = false;
	if (!inited) {
		for (int i =0; i <256; ++i) invs[sbox[i]] = (uint8_t)i;
		inited = true;
	}
	for (int i =0; i <16; ++i) s[i] = invs[s[i]];
}
static void InvShiftRows(uint8_t* s) {
	uint8_t t[16];
	t[0] = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
	t[4] = s[4]; t[5] = s[1]; t[6] = s[14]; t[7] = s[11];
	t[8] = s[8]; t[9] = s[5]; t[10] = s[2]; t[11] = s[15];
	t[12] = s[12]; t[13] = s[9]; t[14] = s[6]; t[15] = s[3];
	std::memcpy(s, t,16);
}
static void InvMixColumns(uint8_t* s) {
	for (int c =0; c <4; ++c) {
		int i =4 * c;
		uint8_t a0 = s[i], a1 = s[i +1], a2 = s[i +2], a3 = s[i +3];
		s[i] = (uint8_t)(mul(a0,0x0e) ^ mul(a1,0x0b) ^ mul(a2,0x0d) ^ mul(a3,0x09));
		s[i +1] = (uint8_t)(mul(a0,0x09) ^ mul(a1,0x0e) ^ mul(a2,0x0b) ^ mul(a3,0x0d));
		s[i +2] = (uint8_t)(mul(a0,0x0d) ^ mul(a1,0x09) ^ mul(a2,0x0e) ^ mul(a3,0x0b));
		s[i +3] = (uint8_t)(mul(a0,0x0b) ^ mul(a1,0x0d) ^ mul(a2,0x09) ^ mul(a3,0x0e));
	}
}

static void AES128EncryptBlock(const uint8_t* key, const uint8_t* in, uint8_t* out) {
	uint8_t state[16];
	uint8_t roundKeys[176];
	std::memcpy(state, in,16);
	KeyExpansion(key, roundKeys);
	AddRoundKey(state, roundKeys);
	for (int r =1; r <=9; ++r) {
		SubBytes(state);
		ShiftRows(state);
		MixColumns(state);
		AddRoundKey(state, roundKeys +16 * r);
	}
	SubBytes(state);
	ShiftRows(state);
	AddRoundKey(state, roundKeys +160);
	std::memcpy(out, state,16);
}

static void AES128DecryptBlock(const uint8_t* key, const uint8_t* in, uint8_t* out) {
	uint8_t state[16];
	uint8_t roundKeys[176];
	std::memcpy(state, in,16);
	KeyExpansion(key, roundKeys);
	AddRoundKey(state, roundKeys +160);
	for (int r =9; r >=1; --r) {
		InvShiftRows(state);
		InvSubBytes(state);
		AddRoundKey(state, roundKeys +16 * r);
		InvMixColumns(state);
	}
	InvShiftRows(state);
	InvSubBytes(state);
	AddRoundKey(state, roundKeys);
	std::memcpy(out, state,16);
}

void AESEncryptionSystem::compute() {
	if (currentMode == AESMode::ENCRYPT) {
		AES128EncryptBlock(key_, data_in_, data_out_);
	} else if (currentMode == AESMode::DECRYPT) {
		AES128DecryptBlock(key_, data_in_, data_out_);
	} else {
		std::memcpy(data_out_, data_in_,16);
	}
}

void AESEncryptionSystem::readResult(uint8_t* out) {
	std::memcpy(out, data_out_,16);
}
